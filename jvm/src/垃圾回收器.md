java默认gc回收的类型：
UseSerialGC  UseParallelGC  UseConcMarkSweepGC  UseParNewGC  UseParallelOldGC  UseG1GC

4大垃圾回收算法：引用计数，复制（新生代）：浪费空间，标记清除（老年代）产生碎片，标记压缩（老年代）能解决碎片但是影响性能

7大垃圾回收器:

serial：串行回收
为单线程环境设计只使用一个线程做垃圾回收，不适合服务器

Parallel：并行回收
多个垃圾回收线程并行工作，此时用户线程是暂停的，适合科学计算和大数据平台等弱交互场景
-----------------------------------------------------------------------
上面两个会导致应用程序暂停
-----------------------------------------------------------------------
CMS：并发标记清除
用户线程和垃圾收集线程同时执行（不一定是并行的，可能交替执行），不需要停顿用户线程，互联网公司多用这个，适合对响应时间有要求的场景
执行步骤：
1初始标记：速度很快会暂停所有线程
2.并发标记：和用户线程一起不会暂停，主要标记过程，标记全部对象
3.重新标记：为了修正在并发标记期间，因为用户程序正在运行而导致标记产生变动的一部分对象的标记记录，仍然需要暂停所有工作线程，因为并发标记时，用户线程仍在运行，因此在正式清理前，再做修正
4.并发清除：和用户线程一起，不需要暂停
优点：不需要暂停用户线程
缺点：并发执行，对cpu压力大
     采用的标记清除算法会参数大量碎片
标记清除无法整理空间碎片，CMS提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理)来指定多少次CMS收集之后，进行一次压缩的Full GC
-----------------------------------------------------------------------
不暂停用户线程但是会产生碎片
-----------------------------------------------------------------------
G1：
将堆内存分割成不同的区域然后并发的对其进行垃圾回收
是面向服务端的垃圾收集器
底层原理：Region区域化垃圾收集器：最大的好处是化整为零，避免全内存扫描，只需要按照区域扫面即可
G1将新生代和老年代的划分取消，G1算法将堆划分成若干个区域（Region）

------------------------------------------------------------
与CMS比较的优势：
1.G1不会产生内存碎片
2.可以精确控制停顿，该收集器把堆划分成多个固定大小的区域，每次根据允许停顿的事件去收集垃圾最多的区域
------------------------------------------------------------

G1之前垃圾回收器的特点：
年轻代和老年代是各自独立且连续的内存块
年轻代收集使用复制算法
老年代收集必须扫描整个老年代区域
都是以尽可能少而快速的执行GC为设计原则


查看默认的垃圾回收器：
java -XX:+PrintCommandLineFlags -version

外部启动：
java -server 参数 -jar 文件 